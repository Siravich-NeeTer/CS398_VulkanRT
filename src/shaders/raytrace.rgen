#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64  : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_nonuniform_qualifier : enable

#include "shared_structs.h"
#include "rng.glsl"

#define pi (3.141592)
#define pi2 (2.0*pi)

#define epsilon 1e-6

// The ray payload; structure is defined in shared_structs.h;
// Attached to a ray, and used to communicate between shader stages.
layout(location=0) rayPayloadEXT RayPayload payload;

// Push constant for ray tracing; structure is defined in shared_structs.h;
// Filled in by application, and pushed to shaders as part of the pipeline invocation
layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };

// Ray tracing descriptor set: 0:acceleration structure, and 1: color output image
layout(set=0, binding=0) uniform accelerationStructureEXT topLevelAS;
layout(set=0, binding=1, rgba32f) uniform image2D colCurr; // Output image: m_rtColCurrBuffer
// Many more buffers (at bindings 2 ... 7) will be added to this eventually.
// 2: light buffer
layout(set = 0, binding = 2, scalar) buffer _emitter { Emitter list[]; } emitter;
// 3,4,5,6,7 : History Tracking
layout(set = 0, binding = 3, rgba32f) uniform image2D colPrev;
layout(set = 0, binding = 4, rgba32f) uniform image2D ndCurr;
layout(set = 0, binding = 5, rgba32f) uniform image2D ndPrev;
layout(set = 0, binding = 6, rgba32f) uniform image2D kdCurr;
layout(set = 0, binding = 7, rgba32f) uniform image2D kdPrev;


// Object model descriptor set: 0: matrices, 1:object buffer addresses, 2: texture list
layout(set=1, binding=0) uniform _MatrixUniforms { MatrixUniforms mats; };
layout(set=1, binding=1, scalar) buffer ObjDesc_ { ObjDesc i[]; } objDesc;
layout(set=1, binding=2) uniform sampler2D textureSamplers[];

// Object buffered data; dereferenced from ObjDesc addresses;  Must be global
layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Position, normals, ..
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices
layout(buffer_reference, scalar) buffer Materials {Material m[]; }; // Array of all materials
layout(buffer_reference, scalar) buffer MatIndices {int i[]; }; // Material ID for each triangle

// @@ Raycasting: Write EvalBrdf -- The BRDF lighting calculation
float X(float d)
{
    if(d > 0.0)
        return 1.0;
    else
        return 0.0;
}
float D_Factor(vec3 m, vec3 N, float a)
{
    return X(dot(m, N)) * ((a + 2.0f) / pi2) * pow(dot(m, N), a);
}
vec3 F_Factor(vec3 Ks, float d)
{
    return Ks + (vec3(1.0f) - Ks) * pow(1.0f - abs(d), 5.0f);
}
float G1_Factor(vec3 v, vec3 m, vec3 N, float alpha)
{
    float tan_v = sqrt(1.0f - pow(dot(v, N), 2)) / dot(v, N);
    float a = sqrt(alpha / 2.0f + 1.0f) / tan_v;

    return X(dot(v, m) / dot(v, N)) * (a < 1.6f ? (3.535 * a + 2.181 * a * a) / (1.0 + 2.276 * a + 2.577 * a * a) : 1.0f);
}
float G_Factor(vec3 Wi, vec3 Wo, vec3 m, vec3 N, Material mat)
{
    return G1_Factor(Wi, m, N, mat.shininess) * G1_Factor(Wo, m, N, mat.shininess);
}

vec3 EvalBrdf(vec3 N, vec3 L, vec3 V, Material mat) 
{
    float alpha = mat.shininess;
    vec3 H = normalize(L + V);

    float D = D_Factor(H, N, alpha);
    vec3 F = F_Factor(mat.specular, dot(L, H));
    //float G = 1.0f / pow(dot(L, H), 2.0f);
    float G = G_Factor(L, V, H, N, mat);

    return X(dot(N, L)) * (mat.diffuse / pi) + (D * F * G) / (4.0f * dot(L, N) * dot(V, N));
}

// @@ Pathtracing: Write SampleBrdf, PdfBrdf, ...
//   vec3 SampleBrdf(inout uint seed, in vec3 N) { }
//   float PdfLight(float area) { }
// and more
vec3 SampleLobe(vec3 A, float c, float phi)
{
    float s = sqrt(1.0 - c * c);
    // Create vector K around Z-axis and rotate to A-axis
    vec3 K = vec3(s * cos(phi), s * sin(phi), c);
    
    // A = Z so no rotation
    if(abs(A.z - 1.0) < 1e-3)
        return K;
    // A = -Z so rotate 180 around X axis
    if(abs(A.z + 1.0) < 1e-3)
        return vec3(K.x, -K.y, -K.z);

    // B = Z x A
    vec3 B = normalize(vec3(-A.y, A.x, 0.0));
    vec3 C = cross(A, B);
    
    return K.x * B + K.y * C + K.z * A;
}
vec3 SampleBrdf(inout uint seed, in vec3 N) 
{
    return SampleLobe(N, sqrt(rnd(seed)), 2.0 * pi * rnd(seed));
}
float PdfBrdf(vec3 N, vec3 Wi)
{
    return abs(dot(N, Wi)) / pi;
}

vec3 SampleTriangle(inout uint seed, vec3 A, vec3 B, vec3 C)
{
    float b2 = rnd(seed);
    float b1 = rnd(seed);
    float b0 = 1.0 - b1 - b2;
    
    if(b0 < 0.0)    // Test for outer triangle; If so invert into inner triangle
    {
        b1 = 1.0 - b1;
        b2 = 1.0 - b2;
        b0 = 1.0 - b1 - b2;
    }

    return b0*A + b1*B + b2*C;
}
Emitter SampleLight(inout uint seed)
{
    Emitter randLight = emitter.list[uint(rnd(seed) * emitter.list.length())];
    randLight.point = SampleTriangle(seed, randLight.v0, randLight.v1, randLight.v2);

    return randLight;
}
float PdfLight(Emitter L)
{
    return 1.0 / (L.area * emitter.list.length());
}
vec3 EvalLight(Emitter L)
{
    return L.emission;
}
float GeometryFactor(vec3 Pa, vec3 Na, vec3 Pb, vec3 Nb)
{
    vec3 D = Pa - Pb;
    return abs((dot(D, Na) * dot(D, Nb)) / pow(dot(D, D), 2.0));
}

// Given a ray's payload indicating a triangle has been hit
// (payload.instanceIndex, and payload.primitiveIndex),
// lookup/calculate the material, texture and normal at the hit point
// from the three vertices of the hit triangle.
void GetHitObjectData(out Material mat, out vec3 nrm)
{
    // Object data (containing 4 device addresses)
    ObjDesc    objResources = objDesc.i[payload.instanceIndex];
    
    // Dereference the object's 4 device addresses
    Vertices   vertices    = Vertices(objResources.vertexAddress);
    Indices    indices     = Indices(objResources.indexAddress);
    Materials  materials   = Materials(objResources.materialAddress);
    MatIndices matIndices  = MatIndices(objResources.materialIndexAddress);
  
    // Use gl_PrimitiveID to access the triangle's vertices and material
    ivec3 ind    = indices.i[payload.primitiveIndex]; // The triangle hit
    int matIdx   = matIndices.i[payload.primitiveIndex]; // The triangles material index
    mat = materials.m[matIdx]; // The triangles material

    // Vertex of the triangle (Vertex has pos, nrm, tex)
    Vertex v0 = vertices.v[ind.x];
    Vertex v1 = vertices.v[ind.y];
    Vertex v2 = vertices.v[ind.z];

    // Compute normal at hit position using the provided barycentric coordinates.
    const vec3 bc = payload.bc; // The barycentric coordinates of the hit point
    nrm  = bc.x*v0.nrm + bc.y*v1.nrm + bc.z*v2.nrm; // Normal = combo of three vertex normals

    // If the material has a texture, read texture and use as the
    // point's diffuse color.
    if (mat.textureId >= 0) {
        vec2 uv =  bc.x*v0.texCoord + bc.y*v1.texCoord + bc.z*v2.texCoord;
        uint txtId = objResources.txtOffset + mat.textureId; // tex coord from three vertices
        mat.diffuse = texture(textureSamplers[(txtId)], uv).xyz; }
}

float FindWeight(int i, int j, vec2 offset, ivec2 iloc, vec3 firstNrm, float firstDepth)
{
    const float d_threshold = 0.15;
    const float n_threshold = 0.95;

    vec4 prevNd = imageLoad(ndPrev, iloc + ivec2(i, j));
    vec3 prevNrm = prevNd.xyz;
    float prevDepth = prevNd.w;
    
    // float b = ((1 - i) - offset.x) * ((1 - j) - offset.y);
    
    float b;
    if(i == 0 && j == 0)
        b = (1 - offset.x) * (1 - offset.y);
    else if(i == 1 && j == 0)
        b = (offset.x) * (1 - offset.y);
    else if(i == 0 && j == 1)
        b = (1 - offset.x) * (offset.y);
    else
        b = (offset.x) * (offset.y);
    
    float depthWeight = (abs(firstDepth - prevDepth) < d_threshold ? 1.0 : 0.0);
    float normalWeight = (dot(firstNrm, prevNrm) > n_threshold ? 1.0 : 0.0); 

    return b * depthWeight * normalWeight;
}

void main() 
{
    // @@ Raycasting: Since the alignment of pcRay is SO easy to get wrong, test it
    // here and flag problems with a fully red screen.
    if (pcRay.alignmentTest != 1234) {
        imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(1,0,0,0));
        return; }
    
    // This shader's invocation is for the pixel indicated by
    // gl_LaunchIDEXT. Calculate that pixel's center (in NDC) and
    // convert to a ray in world coordinates.
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    vec2 pixelNDC = pixelCenter/vec2(gl_LaunchSizeEXT.xy)*2.0 - 1.0;
 
    vec3 eyeW    = (mats.viewInverse * vec4(0, 0, 0, 1)).xyz;
    vec4 pixelH = mats.viewInverse * mats.projInverse * vec4(pixelNDC.x, pixelNDC.y, 1, 1);
    vec3 pixelW = pixelH.xyz/pixelH.w;

    // This pixel's ray:
    vec3 rayOrigin    = eyeW;
    vec3 rayDirection = normalize(pixelW - eyeW);

    // The ray-casting / path-tracing block/loop will store the
    // pixel's calculated color in C.
    vec3 C = vec3(0,0,0);
    // The path tracing algorithm will accumulate a product of f/p weights in W.
    vec3 W = vec3(1,1,1);
    
    // @@ Pathtracing: Initialize random pixel seed *very* carefully! (See notes.)
    payload.seed = tea(gl_LaunchIDEXT.y*gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, pcRay.frameSeed);
    // @@ History: Initialize first-hit data
    bool firstHit;
    float firstDepth;
    vec3 firstNrm, firstKd, firstPos;

    vec3 oldAve = vec3(0, 0, 0), newAve = vec3(0, 0, 0);
    float oldN = 0.0, newN = 0.0;

    // @@ Raycasting: Put all the ray casting code in this loop that's
    // not really a loop since it executes only once.  WHY?  Just
    // looking ahead a bit into the next (path tracing) project.

    // @@ Pathtracing: Eventually, this will be the Monte-Carlo loop.
    for (int i=0; i<pcRay.depth;  i++)
    {
        payload.hit = false;
        // Fire the ray;  hit or miss shaders will be invoked, passing results back in the payload
        traceRayEXT(topLevelAS,           // acceleration structure
                    gl_RayFlagsOpaqueEXT, // rayFlags
                    0xFF,                 // cullMask
                    0,                    // sbtRecordOffset for the hitgroups
                    0,                    // sbtRecordStride for the hitgroups
                    0,                    // missIndex
                    rayOrigin,            // ray origin
                    0.001,                // ray min range
                    rayDirection,         // ray direction
                    10000.0,              // ray max range
                    0                     // payload (location = 0)
                    );

        // If nothing was hit
        if (!payload.hit) {
            // @@ Raycasting: break from the (wanna-be) loop
            // @@ Pathtracing: break from the Monte-Carlo loop
            // @@ History: if (i==0) record that a first-hit did not occur
            firstHit = false;
            break;
        }
        
        // If something was hit, find the object data.
        Material mat;
        vec3 nrm;
        GetHitObjectData(mat, nrm);
        
        // @@ History: if (i==0) record first-hit stuff.
        if(i == 0)
        {
            firstHit = payload.hit;
            firstDepth = payload.hitDist;
            firstPos = payload.hitPos;
            firstKd = mat.diffuse;
            firstNrm = nrm;
        }
        
        // If the material indicates the hit triangle is a light, output (via C):
        // @@ RayCasting: the light's emission value possibly scaled by an exposure value
        // @@ Pathtracing: the light's emission value times all the paths BRDFs (in W)
        // @@ Then (in either case) break from MC loop.
        if (dot(mat.emission,mat.emission) > 0.0) 
        {
            if(pcRay.explicitLight)
                C += 0.5 * mat.emission * W;
            else
                C += mat.emission * W;
            break; 
        }

        // @@ Explicit light connection (if implemented) goes here
        if(pcRay.explicitLight)
        {
            Emitter light = SampleLight(payload.seed);
            vec3 Wi =  normalize(light.point - payload.hitPos);
            float dist = length(light.point - payload.hitPos);
            payload.hit = true;

            traceRayEXT(topLevelAS,                         // acceleration structure
                    gl_RayFlagsOpaqueEXT                    // rayFlags
                    | gl_RayFlagsTerminateOnFirstHitEXT
                    | gl_RayFlagsSkipClosestHitShaderEXT,
                    0xFF,                                   // cullMask
                    0,                                      // sbtRecordOffset for the hitgroups
                    0,                                      // sbtRecordStride for the hitgroups
                    0,                                      // missIndex
                    payload.hitPos,                         // ray origin
                    0.001,                                  // ray min range
                    Wi,                                     // ray direction
                    dist - 0.001,                           // ray max range
                    0                                       // payload (location = 0)
                    );

            if(!payload.hit)
            {
                vec3 N = normalize(nrm);
                vec3 Wo = -rayDirection;
                vec3 f = EvalBrdf(N, Wi, Wo, mat);
                float p = PdfLight(light) / GeometryFactor(payload.hitPos, N, light.point, light.normal);
                
                C += 0.5 * W * f/p * EvalLight(light);
            }
        }
        // @@ End of explicit light connection


        // @@ Raycasting: Do lighting calculation here
        //   as  LIGHT * (N dot L) * EvalBRDF(N, L, V, mat)
        // Data for the calculation:
        //   Normal N from nrm above 
        //   Light direction L from pcRay.tempLightPos-payload.hitPos
        //   View direction V is the -rayDirection (Note the negation!)
        //   Light values from pcRay
        //   Material properties from mat (above), possibly modified by a texture
        //   C += abs(nrm);  // This is a great debugging aid;  But ultimately, replace this.
        /*
        vec3 N = nrm;
        vec3 L = normalize(vec3(pcRay.tempLightPos) - payload.hitPos);
        vec3 V = -rayDirection;
        //vec3 Light = pcRay.tempAmbient.xyz;
        vec3 Light = pcRay.tempLightInt.xyz;
        C += Light * dot(N, L) * EvalBrdf(N, L, V, mat);
        */

        // @@ Pathtracing:  Accumulate product of lighting calculations into W.
        //   Sample random direction Wi = ?
        //   Calculate f = (N dot Wi) * EvalBRDF(N, L, V, mat)
        //   Calculate p = ?
        //   Accumulate f/p into W;  No C += here anymore.
        //   Setup for next loop iteration.
        vec3 P = payload.hitPos;     // Current Hit Point
        vec3 N = normalize(nrm);    // Its normal
        // Wi and Wo play the same role as L and V, in most presentations of BRDF
        vec3 Wi = SampleBrdf(payload.seed, N);   // Importance sample output direction
        vec3 Wo = -rayDirection;

        vec3 f = dot(N, Wi) * EvalBrdf(N, Wi, Wo, mat);      // Color(vec3) according to BRDF
        float p = PdfBrdf(N, Wi) * pcRay.rr;    // Probability(float) of above sample of Wi
        if(p < epsilon)
            break;
        W *= f/p;   // Monte-Carlo estimator

        // Step forward for next loop iteration
        rayOrigin = payload.hitPos;
        rayDirection = Wi;
        // End of Loop

    } // End of Monte-Carlo block/loop

    // @@ Raycasting: Write C to the output pixel
    // imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(C,1.0));
    // @@ Pathtracing: Accumulate C into output pixel.
    /*
    if(pcRay.clear)
        imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(C,1.0));
    else
    {
        vec4 old = imageLoad(colCurr, ivec2(gl_LaunchIDEXT.xy));
        vec3 Ave = old.xyz;
        float Nw = old.w;

        imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(Ave, Nw + 1));
    }
    */

    // @@ History: Accumulate C with <whatever> and write to the output pixel
    vec4 screenH = (mats.priorViewProj * vec4(firstPos, 1.0));  // Project to prev buffers
    vec2 screen = ((screenH.xy / screenH.w) + vec2(1.0)) / 2.0; // H-division and map to [0, 1]
    
    // Calculate Previous Frame Accumulation
    vec2 floc = screen * gl_LaunchSizeEXT.xy - vec2(0.5);
    vec2 offset = fract(floc);                              // 0 to 1 offset between 4 neighbors
    ivec2 iloc = ivec2(floc);                                // (0, 0) corner of the 4 neighbors

    float w00 = FindWeight(0, 0, offset, iloc, firstNrm, firstDepth);
    float w10 = FindWeight(1, 0, offset, iloc, firstNrm, firstDepth);
    float w01 = FindWeight(0, 1, offset, iloc, firstNrm, firstDepth);
    float w11 = FindWeight(1, 1, offset, iloc, firstNrm, firstDepth);

    vec4 P00 = imageLoad(colPrev, iloc + ivec2(0, 0));
    vec4 P10 = imageLoad(colPrev, iloc + ivec2(1, 0));
    vec4 P01 = imageLoad(colPrev, iloc + ivec2(0, 1));
    vec4 P11 = imageLoad(colPrev, iloc + ivec2(1, 1));

    vec4 P = (w00 * P00 + w10 * P10 + w01 * P01 + w11 * P11) / (w00 + w10 + w01 + w11);

    oldAve = P.xyz;
    oldN = P.w;

    if(firstHit == false ||
        (screen.x < 0.0 || screen.x > 1.0) || (screen.y < 0.0 || screen.y > 1.0) ||
        any(isnan(P)) || any(isinf(P)))
    {
        oldAve = vec3(0.5);
        oldN = 1;
    }

    newAve = oldAve + (C - oldAve) / oldN;
    newN = oldN + 1;

    if(any(isnan(newAve)) || any(isinf(newAve)) || 
    any(isnan(firstKd)) || any(isinf(firstKd)) || 
    any(isnan(firstNrm)) || any(isinf(firstNrm)) || 
    isnan(firstDepth) || isinf(firstDepth))
    {
        return;
    }

    imageStore(colCurr, ivec2(gl_LaunchIDEXT.xy), vec4(newAve, newN));
    imageStore(kdCurr, ivec2(gl_LaunchIDEXT.xy), vec4(firstKd, 0.0));
    imageStore(ndCurr, ivec2(gl_LaunchIDEXT.xy), vec4(firstNrm, firstDepth));
}

//  LocalWords:  Pathtracing Raycasting
